local function get_pos(x, y)
	local level_pos = go.get_position("level")
	return vmath.vector3(x * 64 - 32 + level_pos.x, y * 64 - 32 + level_pos.y, level_pos.z)
end

local function get_rev_pos(x, y)
	local level_pos = go.get_position("level")
	return vmath.vector3(math.ceil((x - level_pos.x) / 64), math.ceil((y - level_pos.y) / 64), 0)
end
	
local function add_mines(self)
	local x, y, w, h = tilemap.get_bounds("board#tiles")
	for ix = x, x + w - 1 do
		for iy = y, y + h - 1 do
			pos = get_pos(ix, iy)
			self.mines[ix .. ":" .. iy] = factory.create("#mines_factory", pos)
		end
	end
end

local function hide_colors(self)
	for key, value in pairs(self.mines) do
		local sprite_url = msg.url(nil, value, "sprite")
		sprite.play_flipbook(sprite_url, "mine")
	end
end

local function timer_callback(self, handle, time_elapsed)
	hide_colors(self)
	self.blocked = false
end

function init(self)
	msg.post(".", "acquire_input_focus")
	
	self.mines = {}
	self.completed = false
	self.blocked = true
	self.choose = nil
	add_mines(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("start_game") then
		for key, value in pairs(self.mines) do
			msg.post(value, "randomize")
		end
		timer.delay(1, false, timer_callback)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and not self.completed and action.pressed and not self.blocked then
		local pos = get_rev_pos(action.x, action.y)
		local x = pos.x
		local y = pos.y
		if x <= 0 or y <= 0 then
			return
		end
		local mine_id = x .. ":" .. y
		if self.choose == nil then
			local url = msg.url(nil, self.mines[mine_id], "mine")
			self.choose = go.get(url, "color")
		end
		msg.post(self.mines[mine_id], "color")
	end
end
